local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()

local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local currentCamera = workspace.CurrentCamera
local worldToViewportPoint = currentCamera.worldToViewportPoint

local HeadOff = Vector3.new(0, 0.5, 0)
local LegOff = Vector3.new(0, 3, 0)

local ESP = loadstring(game:HttpGet("https://raw.githubusercontent.com/linemaster2/esp-library/main/library.lua"))();

ESP.Enabled = true;
ESP.Teamcheck = false;
ESP.ShowName = false;
ESP.ShowDistance = false;

_G.teamcheck = false
_G.teamcheckmode = "colors"
_G.teamcolor = Color3.new(0, 1, 0)
_G.enemycolor = Color3.new(1, 0, 0)

_G.boxColor = Color3.new(0, 0, 0)
_G.boxThickness = 1
_G.boxTransparency = 1
_G.boxVisible = false

_G.boxFilledColor = Color3.new(0, 0, 0)
_G.boxFilledTransparency = 0.5
_G.boxFilledVisible = false

_G.HealthBarThickness = 1
_G.HealthBarVisible = false
_G.HealthBarTransparency = 1
_G.HealthBarColor = Color3.new(0, 1, 0)
_G.HealthBarFilled = true

_G.HealthBarPosition = "Left"

_G.TracerVisible = false
_G.TracerThickness = 1.5
_G.TracerTransparency = 1
_G.TracerColor = Color3.new(0, 0, 0)

_G.TracerFrom = "Bottom"

local function BoxType()
    if _G.BoxType == "2D Box" then
        _G.boxVisible = true
        ESP.ShowBox = false
    elseif _G.BoxType == "Corner Box" then
        _G.boxVisible = false
        ESP.ShowBox = true
    else
        _G.boxVisible = false
        ESP.ShowBox = false
    end
end

local function getTracerFromPosition()
    if _G.TracerFrom == "Bottom" then
        return Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
    elseif _G.TracerFrom == "Middle" then
        return Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    elseif _G.TracerFrom == "Top" then
        return Vector2.new(camera.ViewportSize.X / 2, 0)
    end
end

local function createDrawingObjects()
    local Box = Drawing.new("Square")
    Box.Color = _G.boxColor
    Box.Thickness = _G.boxThickness
    Box.Transparency = _G.boxTransparency
    Box.Filled = false
    Box.Visible = _G.boxVisible

    local BoxFilled = Drawing.new("Square")
    BoxFilled.Visible = _G.boxFilledVisible
    BoxFilled.Color = _G.boxFilledColor
    BoxFilled.Transparency = _G.boxFilledTransparency
    BoxFilled.Filled = true

    local HealthBar = Drawing.new("Square")
    HealthBar.Thickness = _G.HealthBarThickness
    HealthBar.Visible = _G.HealthBarVisible
    HealthBar.Transparency = _G.HealthBarTransparency
    HealthBar.Color = _G.HealthBarColor
    HealthBar.Filled = _G.HealthBarFilled

    local Tracer = Drawing.new("Line")
    Tracer.Visible = _G.TracerVisible
    Tracer.Thickness = _G.TracerThickness
    Tracer.Transparency = _G.TracerTransparency
    Tracer.Color = _G.TracerColor

    return Box, BoxFilled, HealthBar, Tracer
end

local function updateDrawingObjects(Box, BoxFilled, HealthBar, Tracer)
    Box.Color = _G.boxColor
    Box.Thickness = _G.boxThickness
    Box.Transparency = _G.boxTransparency
    Box.Visible = _G.boxVisible

    BoxFilled.Color = _G.boxFilledColor
    BoxFilled.Transparency = _G.boxFilledTransparency
    BoxFilled.Visible = _G.boxFilledVisible

    HealthBar.Thickness = _G.HealthBarThickness
    HealthBar.Visible = _G.HealthBarVisible
    HealthBar.Transparency = _G.HealthBarTransparency
    HealthBar.Color = _G.HealthBarColor
    HealthBar.Filled = _G.HealthBarFilled

    Tracer.Visible = _G.TracerVisible
    Tracer.Thickness = _G.TracerThickness
    Tracer.Transparency = _G.TracerTransparency
    Tracer.Color = _G.TracerColor

end

local function getHealthValues(player)
    local maxHealth, health
    if player:FindFirstChild("NRPBS") then
        maxHealth = player.NRPBS["MaxHealth"].Value
        health = player.NRPBS["Health"].Value
    else
        maxHealth = player.Character.Humanoid.MaxHealth
        health = player.Character.Humanoid.Health
    end
    return maxHealth, health
end

local function updateHealthBarPosition(HealthBar, Box, HeadPosition, LegPosition, RootPosition, isOutline, maxHealth, health)
    local offset = isOutline and 6 or 4
    local healthBarSize = (HeadPosition.Y - LegPosition.Y) / (maxHealth / math.clamp(health, 0, maxHealth))

    if _G.HealthBarPosition == "Left" then
        HealthBar.Position = Vector2.new(Box.Position.X - offset, Box.Position.Y)
        HealthBar.Size = Vector2.new(2, healthBarSize)
    elseif _G.HealthBarPosition == "Right" then
        HealthBar.Position = Vector2.new(Box.Position.X + Box.Size.X + offset - 2, Box.Position.Y)
        HealthBar.Size = Vector2.new(2, healthBarSize)
    elseif _G.HealthBarPosition == "Bottom" then
        HealthBar.Position = Vector2.new(Box.Position.X, Box.Position.Y + offset)
        HealthBar.Size = Vector2.new(Box.Size.X, 2)
    elseif _G.HealthBarPosition == "Top" then
        HealthBar.Position = Vector2.new(Box.Position.X, Box.Position.Y + Box.Size.Y - offset)
        HealthBar.Size = Vector2.new(Box.Size.X, 2)
    end
end

local function setupPlayerBox(v)
    local Box, BoxFilled, HealthBar, Tracer = createDrawingObjects()

    game:GetService("RunService").RenderStepped:Connect(function()
        updateDrawingObjects(Box, BoxFilled, HealthBar, Tracer)

        if v.Character and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v ~= lplr and v.Character.Humanoid.Health > 0 then
            local Vector, onScreen = camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)

            local RootPart = v.Character.HumanoidRootPart
            local Head = v.Character.Head
            local RootPosition, RootVis = worldToViewportPoint(currentCamera, RootPart.Position)
            local HeadPosition = worldToViewportPoint(currentCamera, Head.Position + HeadOff)
            local LegPosition = worldToViewportPoint(currentCamera, RootPart.Position - LegOff)

            if onScreen then
                local maxHealth, health = getHealthValues(v)

                Box.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                Box.Visible = _G.boxVisible

                BoxFilled.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                BoxFilled.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                BoxFilled.Visible = _G.boxFilledVisible

                HealthBar.Size = Vector2.new(2, (HeadPosition.Y - LegPosition.Y) / (maxHealth / math.clamp(health, 0, maxHealth)))
                updateHealthBarPosition(HealthBar, Box, HeadPosition, LegPosition, RootPosition, false, maxHealth, health)
                HealthBar.Color = Color3.fromRGB(255 - 255 / (maxHealth / health), 255 / (maxHealth / health), 0)
                HealthBar.Visible = _G.HealthBarVisible

                -- Atualizando a posição do Tracer
                Tracer.From = getTracerFromPosition()
                Tracer.To = Vector2.new(Vector.X, Vector.Y)

                if _G.teamcheck == true then
                    if _G.teamcheckmode == "colors" then
                        if v.TeamColor == lplr.TeamColor then
                            Box.Color = _G.teamcolor
                            BoxFilled.Color = _G.teamcolor
                            Tracer.Color = _G.teamcolor
                        else
                            Box.Color = _G.enemycolor
                            BoxFilled.Color = _G.enemycolor
                            Tracer.Color = _G.enemycolor
                        end
                    elseif _G.teamcheckmode == "invisible" then
                        if v.TeamColor == lplr.TeamColor then
                            Box.Visible = false
                            BoxFilled.Visible = false
                            HealthBar.Visible = false
                            Tracer.Visible = false
                            Box.Color = _G.boxColor
                            BoxFilled.Color = _G.boxFilledColor
                            Tracer.Color = _G.TracerColor
                        else
                            Box.Color = _G.enemycolor
                            BoxFilled.Color = _G.enemycolor
                            Tracer.Color = _G.enemycolor
                        end
                    end
                end
            else
                Box.Visible = false
                BoxFilled.Visible = false
                HealthBar.Visible = false
                Tracer.Visible = false
                Box.Color = _G.boxColor
                BoxFilled.Color = _G.boxFilledColor
                Tracer.Color = _G.TracerColor
            end
        else
            Box.Visible = false
            BoxFilled.Visible = false
            HealthBar.Visible = false
            Tracer.Visible = false
        end
    end)
end

for _, player in pairs(game.Players:GetChildren()) do
    setupPlayerBox(player)
end

game.Players.PlayerAdded:Connect(function(player)
    setupPlayerBox(player)
end)

local SilentAimEnabled = false
local WallCheckEnabled = false
local FOV = 75
local FOVVisible = false
local FOVPosition = "Center"
local FOVCircle = Drawing.new("Circle")
local TeamCheckEnabled = false
_G.targetPart = "Head"

FOVCircle.Radius = FOV
FOVCircle.Thickness = 1
FOVCircle.Color = Color3.new(1, 1, 1)
FOVCircle.Transparency = 1
FOVCircle.Visible = FOVVisible
FOVCircle.Filled = false
FOVCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)

local function getFOVPosition()
    local camera = workspace.CurrentCamera
    if FOVPosition == "Center" then
        return Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    elseif FOVPosition == "Mouse" then
        local mouse = game.Players.LocalPlayer:GetMouse()
        return Vector2.new(mouse.X, mouse.Y)
    end
end

local function isPlayerInFOV(player)
    local mousePos = getFOVPosition()
    if player.Character and player.Character:FindFirstChild(_G.targetPart) then
        local charPart = player.Character:FindFirstChild(_G.targetPart)
        local screenPos = workspace.CurrentCamera:WorldToViewportPoint(charPart.Position)
        local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude

        return distance <= FOV
    end
    return false
end

local function isVisible(target)
    if WallCheckEnabled then
        if not target or not target.Character or not target.Character:FindFirstChild(_G.targetPart) then
            return false
        end

        local camera = workspace.CurrentCamera
        local targetPartPos = target.Character[targetPart].Position
        local rayOrigin = camera.CFrame.Position
        local rayDirection = (targetPartPos - rayOrigin).Unit * (targetPartPos - rayOrigin).Magnitude

        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character}

        local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

        if raycastResult and raycastResult.Instance then
            return raycastResult.Instance:IsDescendantOf(target.Character)
        end
    end
    return true
end

local function isInFrontOfCamera(player)
    if player.Character and player.Character:FindFirstChild(_G.targetPart) then
        local camera = workspace.CurrentCamera
        local targetPartPos = player.Character[_G.targetPart].Position
        local cameraDirection = camera.CFrame.LookVector
        local directionToPlayer = (targetPartPos - camera.CFrame.Position).Unit

        local dotProduct = cameraDirection:Dot(directionToPlayer)
        return dotProduct > 0
    end
    return false
end

local function getClosestPlayer()
    local closestPlayer = nil
    local players = game.Players:GetPlayers()
    local closestDistance = math.huge
    local mousePos = getFOVPosition()

    for _, player in pairs(players) do
        if player ~= game.Players.LocalPlayer and isVisible(player) then
            if TeamCheckEnabled and player.Team == game.Players.LocalPlayer.Team then
                continue
            end

            if isPlayerInFOV(player) and isInFrontOfCamera(player) then
                local charPart = player.Character:FindFirstChild(_G.targetPart)
                if charPart then
                    local screenPos = workspace.CurrentCamera:WorldToViewportPoint(charPart.Position)
                    local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude

                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function aimAt(target)
    if target and target.Character and target.Character:FindFirstChild(_G.targetPart) then
        local camera = workspace.CurrentCamera
        local aimPosition = target.Character[_G.targetPart].Position
        camera.CFrame = CFrame.new(camera.CFrame.Position, aimPosition)
    end
end

game:GetService("RunService").RenderStepped:Connect(function()
    if SilentAimEnabled then
        local target = getClosestPlayer()
        if target then
            aimAt(target)
        end
    end

    FOVCircle.Position = getFOVPosition()
    FOVCircle.Radius = FOV
    FOVCircle.Visible = FOVVisible
end)

local Window = OrionLib:MakeWindow({Name = "Aimbot + Esp + Hit Box", HidePremium = false, IntroEnabled = false, SaveConfig = true, ConfigFolder = "ESPHUB"})

local Tab = Window:MakeTab({
	Name = "AimBot",
	Icon = ""
})

Tab:AddToggle({
	Name = "Enable Aimbot",
	Default = false,
	Callback = function(Value)
		SilentAimEnabled = Value
	end    
})

Tab:AddToggle({
	Name = "Enable WallCheck",
	Default = false,
	Callback = function(Value)
		WallCheckEnabled = Value
	end    
})

Tab:AddToggle({
	Name = "Enable TeamCheck",
	Default = false,
	Callback = function(Value)
		TeamCheckEnabled = Value
	end    
})

Tab:AddDropdown({
	Name = "Aim Part",
	Default = "Head",
	Options = {"Head", "HumanoidRootPart"},
	Callback = function(Options)
		_G.targetPart = Options[1]
	end    
})

Tab:AddDropdown({
	Name = "Fov Position",
	Default = "Center",
	Options = {"Center", "Mouse"},
	Callback = function(Options)
		FOVPosition = Options[1]
	end    
})

Tab:AddToggle({
	Name = "Show Fov",
	Default = false,
	Callback = function(Value)
		FOVVisible = Value
	end    
})

Tab:AddToggle({
	Name = "Fov Filled",
	Default = false,
	Callback = function(Value)
		FOVCircle.Filled = Value
	end    
})

Tab:AddColorpicker({
	Name = "Fov Color",
	Default = Color3.fromRGB(255, 0, 0),
	Callback = function(Value)
		FOVCircle.Color = Value
	end	  
})

Tab:AddSlider({
	Name = "Fov Size",
	Min = 0,
	Max = 650,
	Default = 100,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "",
	Callback = function(Value)
		FOV = Value
	end    
})

Tab:AddSlider({
	Name = "Fov Thickness",
	Min = 0,
	Max = 1,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.05,
	ValueName = "",
	Callback = function(Value)
		FOV = Value
	end    
})

local Tab1 = Window:MakeTab({
	Name = "Esp",
	Icon = ""
})

Tab1:AddLabel("Geral Settings")

Tab1:AddToggle({
	Name = "Show 2D Box",
	Default = false,
	Callback = function(Value)
		_G.boxVisible = Value
    end
})

Tab1:AddToggle({
	Name = "Box Filled",
	Default = false,
	Callback = function(Value)
		_G.boxFilledVisible = Value
    end
})

Tab1:AddToggle({
	Name = "Show Health Bar",
	Default = false,
	Callback = function(Value)
		_G.HealthBarVisible = Value
    end
})

Tab1:AddToggle({
	Name = "Health Bar Filled",
	Default = false,
	Callback = function(Value)
		_G.HealthBarFilled = Value
    end
})

Tab1:AddToggle({
	Name = "Show Tracer",
	Default = false,
	Callback = function(Value)
		_G.TracerVisible = Value
    end
})

Tab1:AddToggle({
	Name = "Show Name",
	Default = false,
	Callback = function(Value)
		ESP.ShowName = Value
    end
})

Tab1:AddToggle({
	Name = "Show Distance",
	Default = false,
	Callback = function(Value)
		ESP.ShowDistance = Value
    end
})

Tab1:AddToggle({
    Name = "TeamCheck",
	Default = false,
	Callback = function(Value)
		_G.teamcheck = Value
    end
})

Tab1:AddLabel("Color Settings")

Tab1:AddColorpicker({
	Name = "Team Color",
	Default = Color3.fromRGB(255, 0, 0),
	Callback = function(Value)
		_G.teamcolor = Value
	end	  
})

Tab1:AddColorpicker({
	Name = "Enemy Color",
	Default = Color3.fromRGB(255, 0, 0),
	Callback = function(Value)
		_G.enemycolor = Value
	end	  
})

Tab1:AddColorpicker({
	Name = "Box Color",
	Default = Color3.fromRGB(255, 0, 0),
	Callback = function(Value)
		_G.BoxColor = Value
	end	  
})

Tab1:AddColorpicker({
	Name = "Box Filled Color",
	Default = Color3.fromRGB(255, 0, 0),
	Callback = function(Value)
		_G.boxFilledColor = Value
	end	  
})

Tab1:AddColorpicker({
	Name = "Tracer Color",
	Default = Color3.fromRGB(255, 0, 0),
	Callback = function(Value)
		_G.TracerColor = Value
	end	  
})

Tab1:AddLabel("Transparency Settings")

Tab1:AddSlider({
	Name = "Box Transparency",
	Min = 0,
	Max = 1,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.05,
	ValueName = "",
	Callback = function(Value)
		_G.boxTransparency = Value
	end    
})

Tab1:AddSlider({
	Name = "Box Filled Transparency",
	Min = 0,
	Max = 1,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.05,
	ValueName = "",
	Callback = function(Value)
		_G.boxFilledTransparency = Value
	end    
})

Tab1:AddSlider({
	Name = "Health Bar Transparency",
	Min = 0,
	Max = 1,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.05,
	ValueName = "",
	Callback = function(Value)
		_G.HealthBarTransparency = Value
	end    
})

Tab1:AddSlider({
	Name = "Tracer Transparency",
	Min = 0,
	Max = 1,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.05,
	ValueName = "",
	Callback = function(Value)
		_G.TracerTransparency = Value
	end    
})

Tab1:AddLabel("Thickness Settings")

Tab1:AddSlider({
	Name = "Box Thickness",
	Min = 0,
	Max = 10,
	Default = 1.5,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.05,
	ValueName = "",
	Callback = function(Value)
		_G.boxThickness = Value
	end    
})

Tab1:AddSlider({
	Name = "Health Bar Thickness",
	Min = 0,
	Max = 10,
	Default = 1.5,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.05,
	ValueName = "",
	Callback = function(Value)
		_G.HealthBarThickness = Value
	end    
})

Tab1:AddSlider({
	Name = "Tracer Thickness",
	Min = 0,
	Max = 10,
	Default = 1.5,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.05,
	ValueName = "",
	Callback = function(Value)
		_G.TracerThickness = Value
	end    
})

Tab1:AddLabel("Other Settings")

Tab1:AddDropdown({
	Name = "Teamcheck Mode",
	Default = "colors",
	Options = {"colors", "invisible"},
	Callback = function(Options)
		_G.teamcheckmode = Options[1]
	end    
})

Tab1:AddDropdown({
	Name = "Health Bar Position",
	Default = "Left",
	Options = {"Left", "Right", "Top", "Bottom"},
	Callback = function(Options)
		_G.HealthBarPosition = Options[1]
	end    
})

Tab1:AddDropdown({
	Name = "Tracer Position",
	Default = "Bottom",
	Options = {"Bottom", "Middle", "Top"},
	Callback = function(Options)
		_G.TracerFrom = Options[1]
	end    
})

_G.HeadSize = 1
_G.Disabled = false
_G.htry = 0.6
_G.Color = Color3.new(255, 0, 0)
_G.TeamCheck = false

-- Função para verificar se dois jogadores estão no mesmo time
local function mesmoTime(jogador1, jogador2)
    if jogador1.Team == jogador2.Team then
        return true
    end
    return false
end

-- Função para atualizar as propriedades da hitbox
local function atualizarHitbox()
    for _, v in ipairs(game:GetService('Players'):GetPlayers()) do
        if v.Name ~= game:GetService('Players').LocalPlayer.Name then
            if not _G.TeamCheck or mesmoTime(game:GetService('Players').LocalPlayer, v) then
                pcall(function()
                    if _G.Disabled == true then
                        if v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                            local humanoidRootPart = v.Character.HumanoidRootPart
                            humanoidRootPart.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
                            humanoidRootPart.Transparency = _G.htry
                            humanoidRootPart.BrickColor = _G.Color
                            humanoidRootPart.Material = "Neon"
                            humanoidRootPart.CanCollide = false
                        end
                    elseif _G.Disabled == false then
                        if v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                            local humanoidRootPart = v.Character.HumanoidRootPart
                            humanoidRootPart.Size = Vector3.new(2, 2, 2)
                            humanoidRootPart.Transparency = _G.htry
                            humanoidRootPart.BrickColor = _G.Color
                            humanoidRootPart.Material = "Neon"
                            humanoidRootPart.CanCollide = false
                        end
                    end
                end)
            end
        end
    end
end

-- Função chamada a cada quadro (RenderStepped)
game:GetService('RunService').RenderStepped:Connect(function()
    atualizarHitbox()
end)

local Tab3 = Window:MakeTab({
	Name = "Others",
	Icon = ""
})

Tab3:AddToggle({
	Name = "Enable HitBox",
	Default = false,
	Callback = function(Value)
		_G.Disabled = Value
    end
})

Tab3:AddSlider({
	Name = "Hit Box Size Multiplier",
	Min = 0,
	Max = 40,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.5,
	ValueName = "",
	Callback = function(Value)
		_G.HeadSize = Value
	end    
})

Tab3:AddSlider({
	Name = "Hit Box Transparency",
	Min = 0,
	Max = 1,
	Default = 0.05,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.5,
	ValueName = "",
	Callback = function(Value)
		_G.htry = Value
	end    
})

OrionLib:Init()
