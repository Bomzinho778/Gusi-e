local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Universal Aimbot Hub",
   Icon = 0, 
   LoadingTitle = "Loading ...",
   LoadingSubtitle = "by: Bomzinho/Sx_Mods",
   Theme = "Default",

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,

   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil,
      FileName = "BomTrial"
   },

   Discord = {
      Enabled = false, 
      Invite = "noinvitelink", 
      RememberJoins = true 
   },

   KeySystem = True,
   KeySettings = {
      Title = "Key System",
      Subtitle = "Key = BomTrial",
      Note = "Key is on Subtitle",
      FileName = "Bomtrial", 
      SaveKey = false,
      GrabKeyFromSite = false,
      Key = {"BomTrial"}
   }
})

local tab1 = Window:CreateTab("Aimbot", 4483362458) 

local SilentAimEnabled = false
local VisibleCheck = false
local FOV = 100
local FOVVisible = false
local FOVCircle = Drawing.new("Circle")
local targetPart = "HumanoidRootPart"
local isRGB = false

FOVCircle.Radius = FOV
FOVCircle.Thickness = 1
FOVCircle.Color = Color3.new(1, 1, 1)
FOVCircle.Transparency = 1
FOVCircle.Visible = FOVVisible
FOVCircle.Filled = false

local function rgbAnimation()
    local hue = 0
    return function()
        hue = (hue + 0.002) % 1
        return Color3.fromHSV(hue, 1, 1)
    end
end

local getRGBColor = rgbAnimation()

local function updateFOVPosition()
    local camera = workspace.CurrentCamera
    FOVCircle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
end

local function isPlayerInFOV(player)
    if not player or not player.Character or not player.Character:FindFirstChild(targetPart) then
        return false
    end
    local camera = workspace.CurrentCamera
    local screenPos, onScreen = camera:WorldToViewportPoint(player.Character[targetPart].Position)
    if not onScreen then
        return false
    end
    local fovPos = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - fovPos).Magnitude
    return distance <= FOV
end

local function isVisible(player)
    local rayOrigin = workspace.CurrentCamera.CFrame.Position
    local rayDirection = (player.Character[targetPart].Position - rayOrigin).Unit * (player.Character[targetPart].Position - rayOrigin).Magnitude

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return result and result.Instance:IsDescendantOf(player.Character)
end

local function getClosestPlayerInFOV()
    local closestPlayer = nil
    local closestDistance = FOV

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer and player.Character and player.Character:FindFirstChild(targetPart) then
            if not VisibleCheck or (VisibleCheck and isVisible(player)) then
                local camera = workspace.CurrentCamera
                local screenPos, onScreen = camera:WorldToViewportPoint(player.Character[targetPart].Position)

                if onScreen and isPlayerInFOV(player) then
                    local distance = (Vector2.new(screenPos.X, screenPos.Y) - FOVCircle.Position).Magnitude
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function aimAt(target)
    if target and target.Character and target.Character:FindFirstChild(targetPart) then
        local camera = workspace.CurrentCamera
        local aimPosition = target.Character[targetPart].Position
        camera.CFrame = CFrame.new(camera.CFrame.Position, aimPosition)
    end
end

game:GetService("RunService").RenderStepped:Connect(function()
    if FOVVisible then
        updateFOVPosition()
    end

    if SilentAimEnabled then
        local target = getClosestPlayerInFOV()
        if target then
            aimAt(target)
        end
    end

    if isRGB then
        FOVCircle.Color = getRGBColor()
    end
end)

local Paragraph = tab1:CreateParagraph({
    Title = "Aimbot",
    Content = "Um aimbot é uma ferramenta usada em jogos para ajudar os jogadores a mirar automaticamente em seus oponentes. Ele funciona detectando inimigos na tela e ajustando a mira do jogador para atingi-los com precisão."
})

local Toggle = tab1:CreateToggle({
   Name = "Enable Aimbot",
   CurrentValue = false,
   Flag = "Aimbot", 
   Callback = function(Value)
       SilentAimEnabled = Value
   end,
})

local Toggle = tab1:CreateToggle({
   Name = "Visible Check",
   CurrentValue = false,
   Flag = "VisibleCheck", 
   Callback = function(Value)
       VisibleCheck = Value
   end,
})

local Paragraph = tab1:CreateParagraph({
    Title = "FOV do Aimbot",
    Content = "FOV (Field of View) do aimbot é a área em que o aimbot procura por alvos. É como um cone de visão onde o aimbot detecta e trava nos oponentes. Configurar a FOV permite ajustar a precisão e a área de atuação do aimbot."
})

local Slider = tab1:CreateSlider({
    Name = "FOV Size",
    Range = {0, 300},
    Increment = 1,
    Suffix = "Units",
    CurrentValue = 100,
    Flag = "FOVSlider", 
    Callback = function(value)
        if value >= 0 and value <= 300 then
            FOV = value
            FOVCircle.Radius = value
        else
            print("Please enter a value between 0 and 300.")
        end
    end,
})

local Slider = tab1:CreateSlider({
    Name = "FOV Thickness",
    Range = {0, 5},
    Increment = 0.1,
    Suffix = "Units",
    CurrentValue = 1,
    Flag = "FOVThick", 
    Callback = function(value)
        if value >= 0 and value <= 5 then
            FOVCircle.Thickness = value
        else
            print("Please enter a value between 0 and 5.")
        end
    end,
})

local Slider = tab1:CreateSlider({
    Name = "FOV Transparency",
    Range = {0, 1},
    Increment = 0.1,
    Suffix = "Units",
    CurrentValue = 1,
    Flag = "FOVTranspa", 
    Callback = function(value)
        if value >= 0 and value <= 1 then
            FOVCircle.Transparency = value
        else
            print("Please enter a value between 0 and 1.")
        end
    end,
})

local Toggle = tab1:CreateToggle({
    Name = "Show FOV",
    CurrentValue = false,
    Flag = "ShowFOV", 
    Callback = function(value)
        FOVVisible = value
        FOVCircle.Visible = value
    end,
})

local Toggle = tab1:CreateToggle({
    Name = "FOV Filled",
    CurrentValue = false,
    Flag = "FOVFill", 
    Callback = function(value)
        FOVCircle.Filled = value
    end,
})

local ToggleRGB = tab1:CreateToggle({
    Name = "Enable RGB",
    CurrentValue = false,
    Flag = "EnableRGBToggle", 
    Callback = function(Value)
        isRGB = Value
    end,
})

local ColorPicker = tab1:CreateColorPicker({
    Name = "FOV Color",
    Color = Color3.fromRGB(255, 255, 255), 
    Flag = "FOVColorPicker", 
    Callback = function(value)
        if not isRGB then
            FOVCircle.Color = value
        end
    end,
})

local Dropdown = tab1:CreateDropdown({
    Name = "Aim Target",
    Options = {"Head", "HumanoidRootPart"},
    CurrentOption = {"HumanoidRootPart"}, 
    MultipleOptions = false,
    Flag = "AimTargetDropdown", 
    Callback = function(options)
        targetPart = options[1]
    end,
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local ESP = {
    Enabled = false,  -- Inicialmente desativado
    BoxThickness = 2,
    BoxTransparency = 1,
    BoxColor = Color3.new(1, 1, 1),
    Visible = false,  -- Inicialmente invisível
    RGBEnabled = false  -- Inicialmente sem RGB
}

local playerESP = {}

local function updateESPVisibility()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and playerESP[player] then
            playerESP[player].Visible = ESP.Visible
        end
    end
end

local function updateESPSettings()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and playerESP[player] then
            playerESP[player].Thickness = ESP.BoxThickness
            playerESP[player].Transparency = ESP.BoxTransparency
            playerESP[player].Color = ESP.BoxColor
        end
    end
end

local function createESP(player)
    if player == LocalPlayer then return end

    local character = player.Character
    if not character then return end

    local box = Drawing.new("Square")
    box.Visible = ESP.Visible
    box.Thickness = ESP.BoxThickness
    box.Transparency = ESP.BoxTransparency
    box.Color = ESP.BoxColor

    local function update()
        if character and character:FindFirstChild("HumanoidRootPart") then
            local rootPart = character.HumanoidRootPart
            local head = character:FindFirstChild("Head")

            if head then
                local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)
                local rootPos, rootOnScreen = Camera:WorldToViewportPoint(rootPart.Position)

                if headOnScreen and rootOnScreen then
                    local height = math.abs(headPos.Y - rootPos.Y) * 3
                    local width = height / 2

                    box.Size = Vector2.new(width, height)
                    box.Position = Vector2.new(rootPos.X - box.Size.X / 2, rootPos.Y - box.Size.Y / 2)
                    box.Visible = ESP.Visible

                    if ESP.RGBEnabled then
                        local hue = tick() % 5 / 5
                        box.Color = Color3.fromHSV(hue, 1, 1)
                    end
                else
                    box.Visible = false
                end
            else
                box.Visible = false
            end
        else
            box.Visible = false
        end
    end

    RunService.RenderStepped:Connect(update)

    player.CharacterRemoving:Connect(function()
        box:Remove()
    end)

    playerESP[player] = box
end

local function addESPToPlayer(player)
    if player.Character then
        createESP(player)
    end
    player.CharacterAdded:Connect(function()
        createESP(player)
    end)
end

Players.PlayerAdded:Connect(addESPToPlayer)

for _, player in ipairs(Players:GetPlayers()) do
    addESPToPlayer(player)
end

-- Função de callback para o toggle de visibilidade
local function toggleESPVisibility(value)
    ESP.Visible = value
    updateESPVisibility()
end

-- Função para atualizar configurações da ESP
local function updateESPSettings()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and playerESP[player] then
            playerESP[player].Thickness = ESP.BoxThickness
            playerESP[player].Transparency = ESP.BoxTransparency
            playerESP[player].Color = ESP.BoxColor
        end
    end
end

-- Função de callback para o toggle RGB
local function toggleRGB(value)
    ESP.RGBEnabled = value
end

-- Configurando a Rayfield UI com Key System
-- Criando a aba "Box ESP" com uma imagem
local Tab = Window:CreateTab("Box ESP", 4483362458)

local Paragraph = Tab:CreateParagraph({
    Title = "ESP Box",
    Content = "ESP Box é uma ferramenta usada em jogos que desenha uma caixa ao redor dos oponentes, permitindo que os jogadores os vejam através de paredes e outros obstáculos. Isso ajuda a rastrear a posição dos inimigos, oferecendo uma visão clara e contínua de sua localização no jogo."
})

-- Adicionando o toggle de exemplo
local Toggle = Tab:CreateToggle({
   Name = "Enable ESP",
   CurrentValue = ESP.Visible,
   Flag = "EnableESP", 
   Callback = function(value)
       toggleESPVisibility(value)
   end,
})

-- Adicionando sliders para espessura e transparência ao GUI usando a Rayfield Library
Tab:CreateSlider({
    Name = "Box Thickness",
    Range = {1, 5},
    Increment = 0.1,
    Suffix = "Thickness",
    CurrentValue = ESP.BoxThickness,
    Flag = "BoxThickness",
    Callback = function(value)
        ESP.BoxThickness = value
        updateESPSettings()
    end
})

Tab:CreateSlider({
    Name = "Box Transparency",
    Range = {0, 1},
    Increment = 0.1,
    Suffix = "Transparency",
    CurrentValue = ESP.BoxTransparency,
    Flag = "BoxTransparency",
    Callback = function(value)
        ESP.BoxTransparency = value
        updateESPSettings()
    end
})

-- Adicionando Color Picker para o GUI usando a Rayfield Library
local ColorPicker = Tab:CreateColorPicker({
    Name = "Box Color",
    Color = Color3.fromRGB(255,255,255),
    Flag = "BoxColor",
    Callback = function(value)
        ESP.BoxColor = value
        updateESPSettings()
    end
})

-- Adicionando Toggle para RGB Animation
local RGBToggle = Tab:CreateToggle({
    Name = "Enable RGB",
    CurrentValue = ESP.RGBEnabled,
    Flag = "RGBToggle",
    Callback = function(value)
        toggleRGB(value)
    end,
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local ESP = {
    Enabled = false,  -- Inicialmente desativado
    LineThickness = 2,
    LineTransparency = 1,
    LineColor = Color3.new(1, 1, 1),
    Visible = false,  -- Inicialmente invisível
    RGBEnabled = false,  -- Inicialmente sem RGB
    OriginalColor = Color3.new(1, 1, 1) -- Cor original para voltar depois do RGB
}

local playerESP = {}

local function updateESPVisibility()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and playerESP[player] then
            playerESP[player].Visible = ESP.Visible
        end
    end
end

local function updateESPSettings()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and playerESP[player] then
            playerESP[player].Thickness = ESP.LineThickness
            playerESP[player].Transparency = ESP.LineTransparency
            playerESP[player].Color = ESP.LineColor
        end
    end
end

local function createESP(player)
    if player == LocalPlayer then return end

    local character = player.Character
    if not character then return end

    local line = Drawing.new("Line")
    line.Visible = ESP.Visible
    line.Thickness = ESP.LineThickness
    line.Transparency = ESP.LineTransparency
    line.Color = ESP.LineColor

    local function update()
    if character and character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local rootPart = character.HumanoidRootPart

        -- Posição do jogador alvo na tela
        local rootPos, rootOnScreen = Camera:WorldToViewportPoint(rootPart.Position)

        -- Define o ponto inicial como o topo da tela
        local topOfScreen = Vector2.new(Camera.ViewportSize.X / 2, 0)

        if rootOnScreen then
            line.From = topOfScreen
            line.To = Vector2.new(rootPos.X, rootPos.Y)
            line.Visible = ESP.Visible

            -- Atualiza a cor RGB, se habilitado
            if ESP.RGBEnabled then
                local hue = tick() % 5 / 5
                line.Color = Color3.fromHSV(hue, 1, 1)
            else
                line.Color = ESP.OriginalColor
            end
        else
            -- Desativa a linha se o jogador não estiver visível
            line.Visible = false
        end
    else
        -- Desativa a linha se não for possível acessar os humanoids
        line.Visible = false
    end
end

RunService.RenderStepped:Connect(update)

    player.CharacterRemoving:Connect(function()
        line:Remove()
    end)

    playerESP[player] = line
end

local function addESPToPlayer(player)
    if player.Character then
        createESP(player)
    end
    player.CharacterAdded:Connect(function()
        createESP(player)
    end)
end

Players.PlayerAdded:Connect(addESPToPlayer)

for _, player in ipairs(Players:GetPlayers()) do
    addESPToPlayer(player)
end

-- Função de callback para o toggle de visibilidade
local function toggleESPVisibility(value)
    ESP.Visible = value
    updateESPVisibility()
end

-- Função para atualizar configurações da ESP
local function updateESPSettings()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and playerESP[player] then
            playerESP[player].Thickness = ESP.LineThickness
            playerESP[player].Transparency = ESP.LineTransparency
            playerESP[player].Color = ESP.LineColor
        end
    end
end

-- Função de callback para o toggle RGB
local function toggleRGB(value)
    ESP.RGBEnabled = value
    if not value then
        ESP.LineColor = ESP.OriginalColor
        updateESPSettings()
    end
end

local Paragraph = Tab:CreateParagraph({
    Title = "ESP Line",
    Content = "ESP Line é uma ferramenta usada em jogos que desenha linhas dos jogadores até os oponentes. Isso ajuda a visualizar a direção e a distância dos inimigos, permitindo que os jogadores rastreiem e localizem os adversários de forma mais eficaz."
})

-- Adicionando o toggle de exemplo
local Toggle = Tab:CreateToggle({
   Name = "Enable ESP Line",
   CurrentValue = ESP.Visible,
   Flag = "EnableESPLine", 
   Callback = function(value)
       toggleESPVisibility(value)
   end,
})

-- Adicionando sliders para espessura e transparência ao GUI usando a Rayfield Library
Tab:CreateSlider({
    Name = "Line Thickness",
    Range = {1, 5},
    Increment = 0.1,
    Suffix = "Thickness",
    CurrentValue = ESP.LineThickness,
    Flag = "LineThickness",
    Callback = function(value)
        ESP.LineThickness = value
        updateESPSettings()
    end
})

Tab:CreateSlider({
    Name = "Line Transparency",
    Range = {0, 1},
    Increment = 0.1,
    Suffix = "Transparency",
    CurrentValue = ESP.LineTransparency,
    Flag = "LineTransparency",
    Callback = function(value)
        ESP.LineTransparency = value
        updateESPSettings()
    end
})

-- Adicionando Color Picker para o GUI usando a Rayfield Library
local ColorPicker = Tab:CreateColorPicker({
    Name = "Line Color",
    Color = Color3.fromRGB(255,255,255),
    Flag = "LineColor",
    Callback = function(value)
        ESP.LineColor = value
        ESP.OriginalColor = value
        updateESPSettings()
    end
})

-- Adicionando Toggle para RGB Animation
local RGBToggle = Tab:CreateToggle({
    Name = "Enable RGB",
    CurrentValue = ESP.RGBEnabled,
    Flag = "RGBToggle",
    Callback = function(value)
        toggleRGB(value)
    end,
})

local ESP = {
    Enabled = false,
    Transparency = 0.5,
    FillColor = Color3.fromRGB(255, 0, 0),
    OutlineColor = Color3.fromRGB(0, 0, 0),
    RGBEnabled = false -- Controle para o RGB
}

-- Função para criar ou atualizar Highlight
local function updateHighlight(player)
    if player.Character and player ~= game.Players.LocalPlayer then
        local highlight = player.Character:FindFirstChild("Highlight")
        if not highlight then
            highlight = Instance.new("Highlight")
            highlight.Name = "Highlight"
            highlight.Parent = player.Character
            highlight.Adornee = player.Character
        end

        -- Define as cores dinamicamente
        if ESP.RGBEnabled then
            local rgbColor = Color3.fromHSV(tick() % 5 / 5, 1, 1) -- Gera a cor RGB animada
            highlight.FillColor = rgbColor
            highlight.OutlineColor = rgbColor
        else
            highlight.FillColor = ESP.FillColor
            highlight.OutlineColor = ESP.OutlineColor
        end

        highlight.FillTransparency = ESP.Transparency
        highlight.OutlineTransparency = 0
        highlight.Enabled = ESP.Enabled
    end
end

-- Aplica o Highlight em todos os jogadores
local function applyHighlights()
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            updateHighlight(player)
        end
    end
end

-- Configura eventos para aplicar o Highlight em jogadores renascidos
local function setupPlayerHighlight(player)
    if player.Character then
        updateHighlight(player)
    end

    player.CharacterAdded:Connect(function()
        task.wait(1) -- Dá tempo para o personagem carregar
        updateHighlight(player)
    end)
end

-- Configura os eventos para jogadores existentes e futuros
for _, player in ipairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        setupPlayerHighlight(player)
    end
end

game.Players.PlayerAdded:Connect(function(player)
    if player ~= game.Players.LocalPlayer then
        setupPlayerHighlight(player)
    end
end)

-- Atualiza as cores RGB dinamicamente
game:GetService("RunService").RenderStepped:Connect(function()
    if ESP.RGBEnabled and ESP.Enabled then
        applyHighlights()
    end
end)

local Paragraph = Tab:CreateParagraph({
    Title = "Chams",
    Content = "Chams é uma técnica usada em jogos para destacar personagens ou objetos com cores brilhantes e translúcidas. Isso permite que os jogadores vejam através de obstáculos, facilitando a localização e rastreamento dos adversários. Chams melhora a visibilidade e fornece uma vantagem estratégica ao mostrar a posição dos inimigos de maneira clara."
})

-- Toggle para ativar/desativar o ESP
Tab:CreateToggle({
    Name = "Enable Chams",
    CurrentValue = ESP.Enabled,
    Flag = "EnableChams",
    Callback = function(value)
        ESP.Enabled = value
        applyHighlights()
    end
})

-- Toggle para ativar/desativar o RGB
Tab:CreateToggle({
    Name = "Enable RGB",
    CurrentValue = ESP.RGBEnabled,
    Flag = "EnableRGB",
    Callback = function(value)
        ESP.RGBEnabled = value
        applyHighlights()
    end
})

-- Slider para ajustar a transparência do fill
Tab:CreateSlider({
    Name = "Fill Transparency",
    Range = {0, 1},
    Increment = 0.1,
    CurrentValue = ESP.Transparency,
    Flag = "FillTransparency",
    Callback = function(value)
        ESP.Transparency = value
        applyHighlights()
    end
})

-- ColorPicker para ajustar a cor do Fill
Tab:CreateColorPicker({
    Name = "Fill Color",
    Color = ESP.FillColor,
    Flag = "FillColor",
    Callback = function(value)
        ESP.FillColor = value
        applyHighlights()
    end
})

-- ColorPicker para ajustar a cor do Outline
Tab:CreateColorPicker({
    Name = "Outline Color",
    Color = ESP.OutlineColor,
    Flag = "OutlineColor",
    Callback = function(value)
        ESP.OutlineColor = value
        applyHighlights()
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local HealthBarSettings = {
    Enabled = false,
    BarColor = Color3.new(0, 1, 0), -- Cor inicial (verde)
    BarWidth = 5, -- Largura fixa da barra
}

local healthBars = {}

-- Função para criar uma barra de vida
local function createHealthBar()
    local bar = Drawing.new("Square")
    bar.Thickness = 1
    bar.Filled = true
    bar.Transparency = 1
    bar.Color = HealthBarSettings.BarColor
    bar.Visible = false
    return bar
end

-- Atualiza a posição e tamanho da barra de vida
local function updateHealthBar(bar, character)
    if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then
        bar.Visible = false
        return
    end

    local humanoid = character.Humanoid
    local rootPart = character.HumanoidRootPart
    local rootPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

    if onScreen then
        -- Calcula o tamanho da ESP Box
        local distance = (Camera.CFrame.Position - rootPart.Position).Magnitude
        local boxHeight = math.clamp(3000 / distance, 10, 300) -- Altura ajustada pela distância
        local boxWidth = boxHeight / 2 -- Proporção da largura para a altura

        -- Calcula o topo da ESP Box
        local topPos = Vector2.new(rootPos.X - boxWidth / 2, rootPos.Y - boxHeight / 2)
        
        -- Calcula a posição da barra de vida ao lado da ESP Box
        local barHeight = boxHeight * (humanoid.Health / humanoid.MaxHealth) -- Proporcional à vida
        bar.Size = Vector2.new(HealthBarSettings.BarWidth, barHeight)
        bar.Position = Vector2.new(topPos.X - HealthBarSettings.BarWidth - 2, topPos.Y + boxHeight - barHeight) -- Ajustado ao lado esquerdo da ESP Box
        bar.Color = Color3.new(1 - humanoid.Health / humanoid.MaxHealth, humanoid.Health / humanoid.MaxHealth, 0) -- Gradiente vermelho para verde
        bar.Visible = HealthBarSettings.Enabled
    else
        bar.Visible = false
    end
end

-- Adiciona a barra de vida ao jogador
local function addHealthBar(player)
    if player == LocalPlayer then return end

    local healthBar = createHealthBar()
    healthBars[player] = healthBar

    local function characterAdded(character)
        local conn
        conn = RunService.RenderStepped:Connect(function()
            if not character.Parent then
                healthBar.Visible = false
                conn:Disconnect()
            else
                updateHealthBar(healthBar, character)
            end
        end)
    end

    if player.Character then
        characterAdded(player.Character)
    end
    player.CharacterAdded:Connect(characterAdded)

    player.CharacterRemoving:Connect(function()
        healthBar.Visible = false
    end)
end

-- Remove a barra de vida ao jogador sair
local function removeHealthBar(player)
    if healthBars[player] then
        healthBars[player]:Remove()
        healthBars[player] = nil
    end
end

-- Conecta os eventos de jogador
Players.PlayerAdded:Connect(addHealthBar)
Players.PlayerRemoving:Connect(removeHealthBar)
for _, player in ipairs(Players:GetPlayers()) do
    addHealthBar(player)
end

local Paragraph = Tab:CreateParagraph({
    Title = "Health Bar",
    Content = "Health Bar é uma ferramenta visual em jogos que mostra a quantidade de vida restante de um jogador ou personagem. Geralmente representada por uma barra colorida que diminui à medida que o personagem sofre danos, a Health Bar permite que os jogadores monitorem facilmente sua saúde e ajustem suas estratégias de acordo."
})

local Tab = Window:CreateTab("Health Bar Settings")
Tab:CreateToggle({
    Name = "Enable Health Bars",
    CurrentValue = HealthBarSettings.Enabled,
    Callback = function(value)
        HealthBarSettings.Enabled = value
        for _, bar in pairs(healthBars) do
            bar.Visible = value
        end
    end
})





















Rayfield:LoadConfiguration()
