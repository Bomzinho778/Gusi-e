-- Carregar a biblioteca Orion
local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/shlexware/Orion/main/source"))()
local Window = OrionLib:MakeWindow({Name = "Bom_Hub_Aim_V5", HidePremium = true, SaveConfig = true, ConfigFolder = "SilentAimSettings"})

-- Configurar a aba principal
local tab1 = Window:MakeTab({Name = "Aimbot", Icon = "rbxassetid://4483345998", PremiumOnly = false})
local tab2 = Window:MakeTab({Name = "Esp", Icon = "rbxassetid://4483345998", PremiumOnly = false})
local tab3 = Window:MakeTab({Name = "Others", Icon = "rbxassetid://4483345998", PremiumOnly = false})

-- Variáveis de configuração
-- Variáveis de configuração
local SilentAimEnabled = false
local FOV = 100
local FOVVisible = false
local FOVPosition = "Center"
local FOVCircle = Drawing.new("Circle")
local TeamCheckEnabled = true  -- Variável para ativar/desativar o team check

-- Configurar o círculo de FOV
FOVCircle.Radius = FOV
FOVCircle.Thickness = 1
FOVCircle.Color = Color3.new(1, 1, 1)
FOVCircle.Transparency = 1
FOVCircle.Visible = FOVVisible
FOVCircle.Filled = false
FOVCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)

-- Função para obter a posição da FOV
local function getFOVPosition()
    local camera = workspace.CurrentCamera
    if FOVPosition == "Center" then
        return Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    else
        local mouse = game.Players.LocalPlayer:GetMouse()
        return Vector2.new(mouse.X, mouse.Y)
    end
end

-- Função de Silent Aim
local targetPart = "HumanoidRootPart" -- Padrão inicial: "Barriga"

tab1:AddDropdown({
    Name = "Parte do Corpo",
    Options = {"Cabeça", "Barriga"},
    Default = "Barriga",
    Callback = function(selected)
        if selected == "Cabeça" then
            targetPart = "Head"
        elseif selected == "Barriga" then
            targetPart = "HumanoidRootPart"
        end
    end
})

-- Função para verificar se o jogador está dentro do FOV
local function isPlayerInFOV(player)
    local mousePos = getFOVPosition()
    if player.Character and player.Character:FindFirstChild(targetPart) then
        local charPart = player.Character:FindFirstChild(targetPart)
        local screenPos = workspace.CurrentCamera:WorldToViewportPoint(charPart.Position)
        local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude

        return distance <= FOV
    end
    return false
end

-- Função para verificar se há parede no caminho entre a câmera e o alvo
local function isVisible(target)
    if not target or not target.Character or not target.Character:FindFirstChild(targetPart) then
        return false
    end

    local camera = workspace.CurrentCamera
    local targetPartPos = target.Character[targetPart].Position
    local rayOrigin = camera.CFrame.Position
    local rayDirection = (targetPartPos - rayOrigin).Unit * (targetPartPos - rayOrigin).Magnitude

    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character}

    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

    if raycastResult and raycastResult.Instance then
        return raycastResult.Instance:IsDescendantOf(target.Character)
    end

    return true
end

-- Função para verificar se o jogador é inimigo (team check)
local function isEnemy(targetPlayer)
    return targetPlayer.Team ~= game.Players.LocalPlayer.Team
end

-- Função para pegar o jogador mais próximo dentro do FOV
local function getClosestPlayerInFOV()
    local closestPlayer = nil
    local players = game.Players:GetPlayers()
    local closestDistance = FOV
    local mousePos = getFOVPosition()

    for _, player in pairs(players) do
        if player ~= game.Players.LocalPlayer and isPlayerInFOV(player) then
            -- Adicionando o check de equipe aqui
            if TeamCheckEnabled and not isEnemy(player) then
                -- Ignora jogadores da mesma equipe se o team check estiver ativado
                continue
            end

            local charPart = player.Character:FindFirstChild(targetPart)
            if charPart then
                local screenPos = workspace.CurrentCamera:WorldToViewportPoint(charPart.Position)
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude

                if distance < closestDistance and isVisible(player) then
                    closestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer
end

-- Função para mirar no jogador
local function aimAt(target)
    if target and target.Character and target.Character:FindFirstChild(targetPart) then
        local camera = workspace.CurrentCamera
        local aimPosition = target.Character[targetPart].Position
        camera.CFrame = CFrame.new(camera.CFrame.Position, aimPosition)
    end
end

-- Adicionar toggle para ativar/desativar o team check
tab1:AddToggle({
    Name = "Ativar Team Check",
    Default = true,
    Callback = function(value)
        TeamCheckEnabled = value
    end
})

game:GetService("RunService").RenderStepped:Connect(function()
    if SilentAimEnabled then
        local target = getClosestPlayerInFOV()
        if target then
            aimAt(target)
        end
    end
end)

    -- Atualiza a posição do círculo de FOV
    FOVCircle.Position = getFOVPosition()
    FOVCircle.Radius = FOV
    FOVCircle.Visible = FOVVisible
end)

-- Toggle para ativar/desativar o Silent Aim
tab1:AddToggle({
    Name = "Ativar Aimbot",
    Default = false,
    Callback = function(value)
        SilentAimEnabled = value
    end
})

tab1:AddParagraph("Paragraph","Paragraph Content")

tab1:AddDropdown({
    Name = "Posição da FOV",
    Default = "Center",
    Options = {"Center", "Finger"},
    Callback = function(option)
        FOVPosition = option
    end
})

tab1:AddTextbox({
    Name = "Tamanho da FOV (0 - 300)",
    Default = "100",
    TextDisappear = true,
    Callback = function(value)
        local size = tonumber(value)
        if size and size >= 0 and size <= 300 then
            FOV = size
        else
            warn("Tamanho inválido! Use um valor entre 0 e 300.")
        end
    end
})

-- Toggle para mostrar/ocultar o círculo de FOV
tab1:AddToggle({
    Name = "Mostrar FOV",
    Default = false,
    Callback = function(value)
        FOVVisible = value
    end
})

-- Dropdown para selecionar a cor do FOV
local colors = {
    ["Branco"] = Color3.new(1, 1, 1),
    ["Vermelho"] = Color3.new(1, 0, 0),
    ["Verde"] = Color3.new(0, 1, 0),
    ["Azul"] = Color3.new(0, 0, 1),
    ["Amarelo"] = Color3.new(1, 1, 0),
    ["Roxo"] = Color3.new(0.5, 0, 1),
    ["Laranja"] = Color3.new(1, 0.5, 0),
    ["Ciano"] = Color3.new(0, 1, 1),
    ["Rosa"] = Color3.new(1, 0.5, 0.8),
    ["Cinza"] = Color3.new(0.5, 0.5, 0.5)
}

tab1:AddDropdown({
    Name = "Selecione a cor do FOV",
    Options = {"Branco", "Vermelho", "Verde", "Azul", "Amarelo", "Roxo", "Laranja", "Ciano", "Rosa", "Cinza"},
    Default = "Branco",
    Callback = function(selected)
        FOVCircle.Color = colors[selected]
    end
})

tab2:AddParagraph("Paragraph","Paragraph Content")

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local camera = game.Workspace.CurrentCamera

local espEnabled = false
local espColor = Color3.fromRGB(255, 255, 255) -- Branco padrão
local isRGB = false

-- Função para animação RGB com velocidade reduzida
local function rgbAnimation()
    local hue = 0
    return function()
        hue = (hue + 0.002) % 1 -- Velocidade mais lenta (0.002 por frame)
        return Color3.fromHSV(hue, 1, 1)
    end
end

local getRGBColor = rgbAnimation()

local function drawESP(targetPlayer)
    local espBox = Drawing.new("Square")
    espBox.Thickness = 1
    espBox.Filled = false
    espBox.Transparency = 1
    espBox.Visible = false

    RunService.RenderStepped:Connect(function()
        if espEnabled and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = targetPlayer.Character.HumanoidRootPart
            local head = targetPlayer.Character:FindFirstChild("Head")

            if humanoidRootPart and head then
                local rootPos, onScreen = camera:WorldToViewportPoint(humanoidRootPart.Position)
                local headPos, _ = camera:WorldToViewportPoint(head.Position)
                local distance = (headPos - rootPos).magnitude

                if onScreen then
                    espBox.Size = Vector2.new(distance * 2, distance * 3)
                    espBox.Position = Vector2.new(rootPos.X - espBox.Size.X / 2, rootPos.Y - espBox.Size.Y / 2)
                    espBox.Color = isRGB and getRGBColor() or espColor
                    espBox.Visible = true
                else
                    espBox.Visible = false
                end
            else
                espBox.Visible = false
            end
        else
            espBox.Visible = false
        end
    end)
end

local function addESPToPlayer(player)
    if player.Character then
        drawESP(player)
    end
    player.CharacterAdded:Connect(function()
        drawESP(player)
    end)
end

for _, targetPlayer in pairs(Players:GetPlayers()) do
    if targetPlayer ~= LocalPlayer then
        addESPToPlayer(targetPlayer)
    end
end

Players.PlayerAdded:Connect(addESPToPlayer)


tab2:AddToggle({
    Name = "Ativar ESP Box",
    Default = espEnabled,
    Callback = function(state)
        espEnabled = state
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                addESPToPlayer(player)
            end
        end
    end
})

tab2:AddDropdown({
    Name = "Cor da ESP Box",
    Default = "Branco",
    Options = {"Branco", "Vermelho", "Verde", "Azul", "Amarelo", "Roxo", "Laranja", "Ciano", "Rosa", "Cinza", "RGB Animado"},
    Callback = function(option)
        isRGB = (option == "RGB Animado")
        local colors = {
            ["Branco"] = Color3.fromRGB(255, 255, 255),
            ["Vermelho"] = Color3.fromRGB(255, 0, 0),
            ["Verde"] = Color3.fromRGB(0, 255, 0),
            ["Azul"] = Color3.fromRGB(0, 0, 255),
            ["Amarelo"] = Color3.fromRGB(255, 255, 0),
            ["Roxo"] = Color3.fromRGB(128, 0, 128),
            ["Laranja"] = Color3.fromRGB(255, 165, 0),
            ["Ciano"] = Color3.fromRGB(0, 255, 255),
            ["Rosa"] = Color3.fromRGB(255, 192, 203),
            ["Cinza"] = Color3.fromRGB(128, 128, 128)
        }
        if not isRGB then
            espColor = colors[option]
        end
    end
})

tab2:AddParagraph("Paragraph","Paragraph Content")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = game.Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local espLineEnabled = false
local espLineDirection = "Top" -- "Top" ou "Bottom"
local lineColor = Color3.new(1, 0, 0) -- Cor inicial da linha (vermelho)
local lines = {}

local colors = {
    Color3.new(1, 0, 0),   -- Vermelho
    Color3.new(0, 1, 0),   -- Verde
    Color3.new(0, 0, 1),   -- Azul
    Color3.new(1, 1, 0),   -- Amarelo
    Color3.new(1, 0.5, 0), -- Laranja
    Color3.new(0.5, 0, 0.5), -- Roxo
    Color3.new(0, 1, 1),   -- Ciano
    Color3.new(1, 0, 1),   -- Magenta
    Color3.new(0.5, 0.5, 0.5), -- Cinza
    Color3.new(0, 0, 0)    -- Preto
}

local function createESPLine(player)
    local Line = Drawing.new("Line")
    Line.Color = lineColor
    Line.Thickness = 1
    Line.Transparency = 1
    Line.Visible = false

    lines[player] = Line

    RunService.RenderStepped:Connect(function()
        if espLineEnabled and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

            if onScreen then
                if espLineDirection == "Top" then
                    Line.From = Vector2.new(Camera.ViewportSize.X / 2, 0)  -- Linha vindo de cima
                elseif espLineDirection == "Bottom" then
                    Line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)  -- Linha vindo de baixo
                end
                Line.To = Vector2.new(screenPos.X, screenPos.Y)
                Line.Visible = true
            else
                Line.Visible = false
            end
        else
            Line.Visible = false
        end
    end)
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            wait(0)
            createESPLine(player)
        end)
    end
end)

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer and player.Character then
        createESPLine(player)
        player.CharacterAdded:Connect(function()
            wait(0)
            createESPLine(player)
        end)
    end
end

-- GUI controls
tab2:AddToggle({
    Name = "Esp Line",
    Default = espLineEnabled,
    Callback = function(state)
        espLineEnabled = state
        for _, line in pairs(lines) do
            line.Visible = state
        end
    end,
})

tab2:AddDropdown({
    Name = "Cor da Linha",
    Default = "Vermelho",  -- Cor inicial
    Options = {"Vermelho", "Verde", "Azul", "Amarelo", "Laranja", "Roxo", "Ciano", "Magenta", "Cinza", "Preto"},
    Callback = function(selected)
        if selected == "Vermelho" then
            lineColor = colors[1]
        elseif selected == "Verde" then
            lineColor = colors[2]
        elseif selected == "Azul" then
            lineColor = colors[3]
        elseif selected == "Amarelo" then
            lineColor = colors[4]
        elseif selected == "Laranja" then
            lineColor = colors[5]
        elseif selected == "Roxo" then
            lineColor = colors[6]
        elseif selected == "Ciano" then
            lineColor = colors[7]
        elseif selected == "Magenta" then
            lineColor = colors[8]
        elseif selected == "Cinza" then
            lineColor = colors[9]
        elseif selected == "Preto" then
            lineColor = colors[10]
        end
        for _, line in pairs(lines) do
            line.Color = lineColor
        end
    end,
})

tab2:AddParagraph("Paragraph","Paragraph Content")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local chamsEnabled = false
local chamsLoop
local selectedColor = Color3.new(1, 0, 0) -- Cor inicial (vermelho)

-- Lista de cores disponíveis para o Chams
local chamsColors = {
    {Name = "Vermelho", Color = Color3.new(1, 0, 0)},
    {Name = "Verde", Color = Color3.new(0, 1, 0)},
    {Name = "Azul", Color = Color3.new(0, 0, 1)},
    {Name = "Amarelo", Color = Color3.new(1, 1, 0)},
    {Name = "Roxo", Color = Color3.new(0.5, 0, 0.5)},
    {Name = "Laranja", Color = Color3.new(1, 0.5, 0)},
    {Name = "Ciano", Color = Color3.new(0, 1, 1)},
    {Name = "Magenta", Color = Color3.new(1, 0, 1)},
    {Name = "Branco", Color = Color3.new(1, 1, 1)},
    {Name = "Cinza", Color = Color3.new(0.5, 0.5, 0.5)},
    {Name = "Preto", Color = Color3.new(0, 0, 0)},
}

local function applyChams(player)
    if player ~= LocalPlayer and player.Character and not player.Character:FindFirstChild("Chams") then
        local highlight = Instance.new("Highlight")
        highlight.Name = "Chams"
        highlight.FillColor = selectedColor -- Usar a cor selecionada
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 1
        highlight.Parent = player.Character
    end
end

local function toggleChams(state)
    if state then
        chamsLoop = coroutine.wrap(function()
            while chamsEnabled do
                for _, player in pairs(Players:GetPlayers()) do
                    applyChams(player)
                end
                wait(0.25)
            end
        end)
        chamsLoop()
    else
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("Chams") then
                player.Character.Chams:Destroy()
            end
        end
    end
end

tab2:AddToggle({
    Name = "Chams",
    Default = chamsEnabled,
    Callback = function(state)
        chamsEnabled = state
        toggleChams(state)
    end
})

-- Adicionar o Dropdown para escolher a cor
tab2:AddDropdown({
    Name = "Escolher Cor para Chams",
    Default = chamsColors[1].Name,
    Options = {chamsColors[1].Name, chamsColors[2].Name, chamsColors[3].Name, chamsColors[4].Name, chamsColors[5].Name, chamsColors[6].Name, chamsColors[7].Name, chamsColors[8].Name, chamsColors[9].Name, chamsColors[10].Name, chamsColors[11].Name},
    Callback = function(selected)
        for _, color in pairs(chamsColors) do
            if color.Name == selected then
                selectedColor = color.Color -- Atualizar a cor selecionada
                break
            end
        end

        -- Se o Chams estiver ativado, desativa e ativa novamente para aplicar a nova cor
        if chamsEnabled then
            toggleChams(false)
            toggleChams(true)
        end
    end
})

--others

tab3:AddLabel("ByBomzinho")






OrionLib:Init()
